from random import choice
from math import inf, log, sqrt

from .utils import random_rollout


class TreeNode:
    def __init__(self, environment, cache=dict()):
        '''
        Initializes a node for montecarlo tree search.
        '''
        self.environment = environment
        self.num_visits = 0

        # Keeps a list with the current value for each agent.
        self.agent_to_value = [0] * self.environment.num_agents()
        self.is_expanded = False

        # self.children is a dictionary that takes an action and returns the tree_node
        # generated by that action.
        self.children = dict()

        # self.parents is a set that keeps all the parents of node.
        self.parents = set()

        # Cache is a dictionary that takes a node and returns its corresponding tree_node.
        self.cache = cache
        self.cache[environment] = self

    def __repr__(self) -> str:
        return f"Environment {self.environment}, Parent {self.parent}, Action {self.action} "

    def selection(self, exploration_parameter=sqrt(2)):
        '''
        This method returns a list of valid actions with higher ucb score.
        '''
        best_actions = []
        best_score = -inf
        current_player = self.environment.turn()
        for action, child in self.children.items():
            child_value = child.agent_to_value[current_player]
            child_visits = child.num_visits
            score = child_value / child_visits + exploration_parameter * sqrt(
                log(self.num_visits) / child_visits)
            if score == best_score:
                best_actions.append(action)
                best_score = score
            elif score > best_score:
                best_actions.clear()
                best_actions.append(action)
                best_score = score

        return best_actions

    def simulation(self, rollout_strategy=random_rollout):
        '''
        Runs a current environment until a terminal state and returns its value. 
        For expanded nodes, it chooses the next environment based on the selection function. 
        For not expanded nodes, it chooses the next environment using a rollout_strategy.
        The rollout_strategy takes an environment and returns an action. 
        The default rollout_strategy will return a random action from all possible actions.
        '''

        current_node = self
        while current_node.is_expanded and not current_node.environment.is_terminal():
            best_action = choice(current_node.selection())
            current_node = current_node.children[best_action]

        current_environment = current_node.environment
        while not (current_environment.is_terminal()):
            current_environment = rollout_strategy(current_environment)
        
        simulation_value = [
            current_environment.value(k)
            for k in range(current_environment.num_agents())
        ]

        current_node.backpropagation(simulation_value)
        return simulation_value
   
    def expansion(self):
        '''
        Populates the children of a node.
        '''
        if self.is_expanded:
            return

        for action in self.environment.valid_actions():
            child_environment = self.environment.what_if(action)
            child_node = self.cache.get(
                child_environment, TreeNode(child_environment, self.cache))
            child_node.parents.add(self.environment)
            child_node.simulation()
            self.children[action] = child_node

        self.is_expanded = True

    def backpropagation(self, value):
        '''
        Propagates the value from a node to all of its ancesters. 
        '''
        for i in range(len(self.agent_to_value)):
            self.agent_to_value[i] += value[i]

        self.num_visits += 1

        for parent in self.parents:
            parent_node = self.cache.get(parent)
            parent_node.backpropagation(value)
